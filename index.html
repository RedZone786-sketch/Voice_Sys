<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Voice Engine</title>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>
    <style>
        body { background: #000; color: #2ea043; font-family: monospace; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; overflow: hidden; }
        #status { font-size: 14px; text-align: center; padding: 20px; border: 1px dashed #2ea043; border-radius: 10px; width: 80%; }
        .pulse { animation: blink 1s infinite; }
        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.3; } 100% { opacity: 1; } }
    </style>
</head>
<body>

    <div id="status">INITIALIZING VOICE ENGINE...</div>
    <div id="remote-audios"></div>

    <script>
        let database;
        let myUid;
        let localStream;
        const peers = {};
        const iceServers = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

        // 1. Initialize from Android
        window.initVoice = function(configStr, uid) {
            try {
                const config = JSON.parse(configStr);
                firebase.initializeApp(config);
                database = firebase.database();
                myUid = uid;
                
                document.getElementById('status').innerHTML = "READY: " + uid + "<br><span class='pulse'>LISTENING FOR INCOMING...</span>";
                
                setupIncomingListener();
                startLocalStream();
                if(window.AndroidBridge) AndroidBridge.log("Voice Engine Ready: " + uid);
            } catch (e) {
                document.getElementById('status').innerText = "INIT ERROR: " + e.message;
            }
        };

        async function startLocalStream() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                if(window.AndroidBridge) AndroidBridge.log("Microphone Accessed");
            } catch (e) {
                if(window.AndroidBridge) AndroidBridge.log("Mic Error: " + e.message);
            }
        }

        // 2. Listen for others calling ME
        function setupIncomingListener() {
            const myInbox = database.ref(`voiceSignaling/${myUid}`);
            myInbox.on('child_added', async (snapshot) => {
                const data = snapshot.val();
                const fromUid = data.from;

                if (data.type === 'offer') {
                    handleOffer(data.offer, fromUid);
                    myInbox.child(snapshot.key).remove();
                }
            });
        }

        // 3. Connect to someone (Triggered by Android)
        window.connectToUser = async function(remoteUid) {
            if (peers[remoteUid]) return; // Already connected
            
            const pc = createPeerConnection(remoteUid);
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);

            database.ref(`voiceSignaling/${remoteUid}`).push({
                type: 'offer',
                from: myUid,
                offer: { sdp: offer.sdp, type: offer.type }
            });
            
            document.getElementById('status').innerHTML = "Calling: " + remoteUid;
        };

        async function handleOffer(offer, remoteUid) {
            const pc = createPeerConnection(remoteUid);
            await pc.setRemoteDescription(new RTCSessionDescription(offer));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);

            database.ref(`voiceSignaling/${remoteUid}`).push({
                type: 'answer',
                from: myUid,
                answer: { sdp: answer.sdp, type: answer.type }
            });
        }

        // Logic to handle answers
        function createPeerConnection(remoteUid) {
            const pc = new RTCPeerConnection(iceServers);
            peers[remoteUid] = pc;

            if (localStream) {
                localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
            }

            pc.ontrack = (event) => {
                let audio = document.getElementById(`audio-${remoteUid}`);
                if (!audio) {
                    audio = document.createElement('audio');
                    audio.id = `audio-${remoteUid}`;
                    audio.autoplay = true;
                    audio.playsinline = true;
                    document.getElementById('remote-audios').appendChild(audio);
                }
                audio.srcObject = event.streams[0];
                document.getElementById('status').innerHTML = "CONNECTED TO USERS";
            };

            // ICE Candidates
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    database.ref(`voiceIce/${remoteUid}/${myUid}`).push(event.candidate.toJSON());
                }
            };

            // Listen for Remote ICE
            database.ref(`voiceIce/${myUid}/${remoteUid}`).on('child_added', snap => {
                pc.addIceCandidate(new RTCIceCandidate(snap.val()));
            });

            // Listen for Answer
            database.ref(`voiceSignaling/${myUid}`).on('child_added', async (snapshot) => {
                const data = snapshot.val();
                if (data.type === 'answer' && data.from === remoteUid) {
                    await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                    database.ref(`voiceSignaling/${myUid}`).child(snapshot.key).remove();
                }
            });

            return pc;
        }
    </script>
</body>
</html>

